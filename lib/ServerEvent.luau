local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Spawn = require(script.Parent.Parent.Spawn)

local Remote = ReplicatedStorage:WaitForChild("RedEvent") :: RemoteEvent
local ServerEvent = {}

type Data = { [number]: any }
type EventMap = { [string]: { Data } }

ServerEvent.ListenerMap = {} :: { [string]: (Player, ...any) -> () }
ServerEvent.OutgoingMap = {} :: { [Player]: { Fire: EventMap?, Call: { Data }? } }

function ServerEvent.Start()
	debug.setmemorycategory("Red.ServerEvent.Start")

	Remote.OnServerEvent:Connect(function(Player, FireSection, CallSection)
		debug.profilebegin("Red.ServerEvent.Start")

		if FireSection then
			debug.profilebegin("Red.ServerEvent.Start.MultipleFire")

			for EventId, CallList in FireSection do
				local Callback = ServerEvent.ListenerMap[EventId]

				if Callback then
					for _, Call in CallList do
						Spawn(Callback, Player, unpack(Call))
					end
				end
			end

			debug.profileend()
		end

		if CallSection then
			debug.profilebegin("Red.ServerEvent.Start.Call")

			for EventId, CallList in CallSection do
				local Callback = ServerEvent.ListenerMap[EventId]

				if Callback then
					for _, Call in CallList do
						Spawn(function()
							local CallId = table.remove(Call, 1) :: any
							local Result = { CallId, pcall(Callback, Player, unpack(Call)) }

							if not ServerEvent.OutgoingMap[Player] then
								ServerEvent.OutgoingMap[Player] = {}
							end

							if not ServerEvent.OutgoingMap[Player].Call then
								ServerEvent.OutgoingMap[Player].Call = {}
							end

							table.insert((ServerEvent.OutgoingMap[Player].Call :: any), Result)
						end)
					end
				else
					if not ServerEvent.OutgoingMap[Player] then
						ServerEvent.OutgoingMap[Player] = {}
					end

					if not ServerEvent.OutgoingMap[Player].Call then
						ServerEvent.OutgoingMap[Player].Call = {}
					end

					for _, Call in CallList do
						local CallId = table.remove(Call, 1) :: any
						table.insert((ServerEvent.OutgoingMap[Player].Call :: any), { CallId, false, "Event has no listener." })
					end
				end
			end

			debug.profileend()
		end

		debug.profileend()
	end)

	RunService.Heartbeat:Connect(function()
		debug.profilebegin("Red.ServerEvent.Outgoing")

		for Player, Data in ServerEvent.OutgoingMap do
			Remote:FireClient(Player, Data.Fire, Data.Call)
		end

		table.clear(ServerEvent.OutgoingMap)

		debug.profileend()
	end)
end

function ServerEvent.Fire(Player: Player, EventId: string, Args: { any })
	if not ServerEvent.OutgoingMap[Player] then
		ServerEvent.OutgoingMap[Player] = {}
	end

	if not ServerEvent.OutgoingMap[Player].Fire then
		ServerEvent.OutgoingMap[Player].Fire = {}
	end

	if not (ServerEvent.OutgoingMap[Player].Fire :: any)[EventId] then
		(ServerEvent.OutgoingMap[Player].Fire :: any)[EventId] = {}
	end

	table.insert((ServerEvent.OutgoingMap[Player].Fire :: any)[EventId], Args)
end

function ServerEvent.Listen(EventId: string, Callback: (Player, ...any) -> ())
	ServerEvent.ListenerMap[EventId] = Callback
end
function ServerEvent.Unlink(EventId: string)
	ServerEvent.ListenerMap[EventId] = nil
end

return ServerEvent
